#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Sep  7 21:30:15 2024

@author: lemannur
"""
import numpy as np #sayisal hesaplamalar icin
import matplotlib.pyplot as plt #grafikler icin

# in this code:
    #activation of cGAS w dsDNA via Monte Carlo simulation
    #based on 2 - localization
    #based on free cGas+dsDNA hitting numbers that are generated by simulation
    
#notes for development:
    #liquid phase transitions
    #cGAS-dsDNA-spatially concentrated for efficient cGAMP synthesis
    #1. sequence: dsDNA activates-N terminal:DIVERSE+rapidly diverging
    #1. sequence: C-terminal:conserved
    #2: localization
    #3: Ca+signaling
    
#in this code:    
# NO CONSIDERATION of dna size/length 
# CONSIDERATION of spatial locations of nucleus, outside area and mitocondria
# NO CONSIDERATION of the rate of chemical interactions
# NO CONSIDERATION of time interval
# Monte-Carlo simulation 
# The prior probabilities of intensities should be assigned based on wet-lab observations 
# //OR:
# The prior probabilities of intensities should be assigned based on expert knowledge



# Parameters for the simulation with mitochondrial, nucleus, and exosomal entry regions
# asagidaki parametreler update edilecek veriler geldikce
# eksik parametreler: lenght dependence of dna
# question: how to detect lenght of dna?
# eksik parametreler: how to determine the size of mitocondrial areas + nuclear areas + exogenous areas
# question: how to determine dna content in these 3 areas? \ kabaca da olur
# labda bunun imkanlari neler yukaridakinin???? SOR
# eksik parametreler: baska bir sey var mi consider edilmesi gereken?
# eksik parametreler: how to detect this hitting mechanism?

grid_size = 100  # Size of the grid
num_steps = 10000  # Number of steps in the simulation
enum_molecules = 500  # Number of cGAS molecules #bunu wetlabdan sor cell line spesifik 
threshold = 5  # Activation threshold for cGAS #cell line gore degisiyor mu?

# asagidaki problar update edilecek, veriler geldikce
# wet-labdan ya da expert knowledgeden alabilirsin
# bunlar icin distribution yapabilirsin

mitochondrial_area_intensity = 0.7  # Probability of cGAS staying in mitochondrial regions
nucleus_area_intensity = 0.9  # Probability of cGAS staying in nucleus region
exosomal_entry_intensity = 0.7  # Probability of cGAS staying near exosomal entry (grid boundary)

#Intensity haric sunu da gozetmen gerekiyor:
    # N-terminus binds genomic DNA
    # N-terminal domain, highly diverse among mammals 
    # In N-terminal, increase of prior probability of nucleus region
    # N-terminal = self DNA recognition
    # C-terminus binds mitocondiral, pathogenic, dead cell DNA
    # The binding of dsDNA (length > 45 b) - burada da bir pro vermen lazim.
    


# Initialize the grid
#np.zeros() bu fonksiyon 0'dan baslayan bir array olustuyori
#bu fonksiyon veri yapilarinda bir baslangic degeri atamak icin kullaniliyor
#np.zeros((grid_size, grid_size)) grid size'e gore bir iki boyutlu array olustuyor
#yani baslangictaki tum elemanlari 0 olan 2 boyutlu bir grid
#grid = np.zeros((100, 100)) = tum elemanlari 0 olan 100x100luk bir dizi
#bu grid, simulasyon baslangicinda molekullerin konumlarini gostermek icin
#sonrasinda her bir hucre, molekul yogunluguna gore guncellenir
grid = np.zeros((grid_size, grid_size))



#asagida, molekullerin bu bolgelerde daha uzun kalmasini modelliyoruz
# Define mitochondrial regions (arbitrary rectangular areas in the grid)
mitochondrial_regions = [
    (20, 30, 20, 30),  # (x_start, x_end, y_start, y_end)
    (60, 80, 60, 80),
]

# Define nucleus region (a larger rectangular area in the center of the grid)
nucleus_region = (40, 60, 40, 60)  # (x_start, x_end, y_start, y_end)


#burada da exosomal bir girise yakin mi diye bakiyoruz
#exosomal bolgeler, hucre kenarlarina yakin bolgeler
# Function to check if a position is near exosomal entry (i.e., at the boundary)
def is_near_exosomal_entry(x, y, grid_size):
    # Exosomal entry is considered along the boundaries (first 10 and last 10 rows/columns)
    boundary_size = 10
    if x < boundary_size or x >= grid_size - boundary_size or y < boundary_size or y >= grid_size - boundary_size:
        return True
    return False

#bu ikisi de lokasyonu sabit olanlar icin
# Function to check if a position is in any mitochondrial region
def is_in_mitochondrial_region(x, y, mitochondrial_regions):
    for region in mitochondrial_regions:
        if region[0] <= x < region[1] and region[2] <= y < region[3]:
            return True
    return False

# Function to check if a position is in the nucleus region
def is_in_nucleus_region(x, y, nucleus_region):
    return nucleus_region[0] <= x < nucleus_region[1] and nucleus_region[2] <= y < nucleus_region[3]


#rastgele olarak cGAS'lari baslatiyoruz - position assign etme yeri
# Randomly initialize positions of cGAS molecules
positions = np.random.randint(0, grid_size, (num_molecules, 2))


#burada artik hareketi tanimliyoruz
# Function to simulate random movement (diffusion), favoring mitochondrial, nucleus, and exosomal regions
def move(positions, grid_size, mitochondrial_regions, nucleus_region, mitochondrial_area_intensity, nucleus_area_intensity, exosomal_entry_intensity):
    for i in range(len(positions)):
        # Check if current position is in nucleus, mitochondrial region, or near exosomal entry
        in_mitochondria = is_in_mitochondrial_region(positions[i][0], positions[i][1], mitochondrial_regions)
        in_nucleus = is_in_nucleus_region(positions[i][0], positions[i][1], nucleus_region)
        near_exosomal_entry = is_near_exosomal_entry(positions[i][0], positions[i][1], grid_size)
        
        # Higher probability of staying in nucleus regions
        if in_nucleus and np.random.rand() < nucleus_area_intensity:
            continue  # Stay in the same position with a certain probability
        # Higher probability of staying in mitochondrial regions
        elif in_mitochondria and np.random.rand() < mitochondrial_area_intensity:
            continue  # Stay in the same position with a certain probability
        # Higher probability of staying near exosomal entry (boundary)
        elif near_exosomal_entry and np.random.rand() < exosomal_entry_intensity:
            continue  # Stay in the same position with a certain probability
        
        # Random movement if not staying
        direction = np.random.choice(['up', 'down', 'left', 'right'])
        if direction == 'up' and positions[i][0] > 0:
            positions[i][0] -= 1
        elif direction == 'down' and positions[i][0] < grid_size - 1:
            positions[i][0] += 1
        elif direction == 'left' and positions[i][1] > 0:
            positions[i][1] -= 1
        elif direction == 'right' and positions[i][1] < grid_size - 1:
            positions[i][1] += 1
    return positions

# Monte Carlo simulation with mitochondrial, nucleus, and exosomal regions
#monte carlo, yukarida tanimladigin hareket fonskiyonunu birden fazla oynatiyor
#sonra da sonuclari degerlendirir
activations = []
for step in range(num_steps):
    # Move molecules with mitochondrial, nucleus, and exosomal area intensity
    positions = move(positions, grid_size, mitochondrial_regions, nucleus_region, mitochondrial_area_intensity, nucleus_area_intensity, exosomal_entry_intensity)
    
    # Update grid concentrations
    grid = np.zeros((grid_size, grid_size))
    for pos in positions:
        grid[pos[0], pos[1]] += 1
    
    # Check if any location exceeds the activation threshold
    if np.max(grid) >= threshold:
        activations.append(step)
        break

# Plot the final grid with mitochondrial, nucleus, and exosomal regions highlighted
plt.imshow(grid, cmap='hot', interpolation='nearest')

# Highlight mitochondrial regions on the plot
for region in mitochondrial_regions:
    plt.gca().add_patch(plt.Rectangle((region[2], region[0]), region[3]-region[2], region[1]-region[0], 
                                      fill=False, edgecolor='blue', linewidth=2))

# Highlight nucleus region on the plot
plt.gca().add_patch(plt.Rectangle((nucleus_region[2], nucleus_region[0]), nucleus_region[3]-nucleus_region[2], 
                                  nucleus_region[1]-nucleus_region[0], fill=False, edgecolor='green', linewidth=2))

# Highlight exosomal entry regions (the grid boundaries)
plt.gca().add_patch(plt.Rectangle((0, 0), grid_size, 10, fill=False, edgecolor='purple', linewidth=2))  # Top
plt.gca().add_patch(plt.Rectangle((0, grid_size-10), grid_size, 10, fill=False, edgecolor='purple', linewidth=2))  # Bottom
plt.gca().add_patch(plt.Rectangle((0, 0), 10, grid_size, fill=False, edgecolor='purple', linewidth=2))  # Left
plt.gca().add_patch(plt.Rectangle((grid_size-10, 0), 10, grid_size, fill=False, edgecolor='purple', linewidth=2))  # Right

plt.colorbar(label='Concentration')
plt.title('Final Concentration of cGAS Molecules with Mitochondrial, Nucleus, and Exosomal Entry Regions')
plt.show()

# Output the step where activation occurred
if activations:
    print(f"Activation occurred at step: {activations[0]}")
else:
    print("No activation occurred within the simulation steps.")
